#!/bin/bash

################################################################################
# * This script was loosely based on veracodeSTiBuild.sh of 08-Apr-2015.
# * This variant maintains all its ancestors' conventions with respect to log
#   output format, so iosPublishLogs.sh can reformat its log into html.
# * Temporarily replace "^#-#" with "    " to track down mismatched ' " } etc.
################################################################################

# This script will happily run with without any arguments or environment variables
# and generate an unsigned xcode archive
# however if you provide the following extra things will happen.
#
# if BUILD_CONFIGURATION is defined, its value is passed to xcode; known valid
# values are "debug" and "release"; the default if undefined is "debug"
#
# if ST_DEV_ENTITLEMENTS_PATH, the path to an entitments plist
# and ST_DEV_IPA_PROFILE_NAME, the name string from a mobile provisioning profile,
# and ST_DEV_SIGNING_ID, the numeric key value from the keychain,
# are both defined then a developer ipa will be exported
#
# if ST_ENT_ENTITLEMENTS_PATH, the path to an entitments plist
# and ST_ENT_IPA_PROFILE_NAME, the name string from a mobile provisioning profile,
# and ST_ENT_SIGNING_ID, the numeric key value from the keychain,
# are both defined then an enterprise ipa will be exported
#
# if ST_STORE_ENTITLEMENTS_PATH, the path to an entitments plist
# and ST_STORE_SIGNING_ID, the numeric key value from the keychain,
# are both defined then an xcode archive suitable for upload to Apple will be produced


# Tool to adjust contents of Plists.
PlistBuddy=/usr/libexec/PlistBuddy

# Utility function to print boxed text. Argument(s) can contain embedded "\n".
# Note the script that translates this log into html recognizes these boxes, as
# well as lines beginning with "! ", "? " and "+ " (bash -x output).
#
#-# echo "Defining function echo_in_box()"
function echo_in_box()
{
  local IFS=''
  printf "\n"
  printf "$*\n" | \
    awk '{t[++x]=" "$0" "; if ((l=length(t[x]))>w){w=l}} END{for (i=1;i<=w;++i){s=s"-"}; print "."s"."; for(i=1;i<=x;++i){printf "!%-*s!\n",w,t[i]}; print "'\''"s"'\''"}'
  printf "\n"
}


# Utility function to abort the script, printing a message.
# When composing error messages passed to this function, keep in mind that:
# 1) This leaves errorCount.txt containing "Build Aborted".
# 2) The index generated by iosPublishLogs shows this message as a tooltip.
#-# echo "Defining function failed()"
function failed()
{
    local error=${1:-Undefined error}
    echo "Failed: $error" >&2
    exit 1
}


# The following counts errors that make the script's output useless, but are
# not severe enough to abort its execution entirely.  Finishing execution
# sometimes provides clues to the reason for an otherwise obscure error.
errorCount=0            # this is for future use; currently not yet updated

# iosPublishLogs.sh puts errorCount.txt's contents in its title; normally that
# will be Errors:N but in case execution aborts before we have an accurate error
# count:
echo 'Build Aborted' >| errorCount.txt

argcount=$#

echo_in_box 'Describing this script:'
(ls -FTl "$BASH_SOURCE"; ls -FTlL "$BASH_SOURCE") | sort -ru



function configureBuild()
{
  # Forbid parameters, to catch obsolete invocations
  if (( $argcount != 0 )); then
    failed "This script does not allow any parameters"
  fi

  echo '! Showing BUILD_CONFIGURATION:'
  echo "    ${BUILD_CONFIGURATION=Debug}"
  echo '! Showing BUILD_OPTIONS:'
  echo "    ${BUILD_OPTIONS=}"
  echo '! Showing VERIFY_OPTIONS:'
  echo "    ${VERIFY_OPTIONS=--no-strict}"
}

echo_in_box "Constructing and describing build configuration and options:"
configureBuild


# Symbols shared across functions shall use BUILD_* symbols; fix flaws as found.
# BUILD_*_NAME are a single token with no "/" or ".ext" .
# BIULD_*_PATH are absolute paths.

BUILD_BASE=`pwd`

BUILD_APP_ARCHS="armv7 arm64"
BUILD_APP_NAME="Silent Text"
BUILD_PROJECT_NAME="ST2"
BUILD_WORKSPACE_NAME="$BUILD_PROJECT_NAME"

BUILD_ARCHIVE_NAME="SilentText"
BUILD_ARCHIVE_PATH="$BUILD_BASE/$BUILD_ARCHIVE_NAME.xcarchive"

DEV_IPA_NAME="SilentText"
DEV_IPA_PATH="$BUILD_BASE/$DEV_IPA_NAME.ipa"
DEV_IPA_KIT="silenttext"
DEV_IPA_KIT_PATH="$BUILD_BASE/$DEV_IPA_KIT"

ENT_IPA_BUNDLE_ID=com.silentcircle.enterprisetext
ENT_IPA_BUNDLE_DISPLAY_NAME="Enterprise Text"

ENT_IPA_NAME="EnterpriseText"
ENT_IPA_PATH="$BUILD_BASE/$ENT_IPA_NAME.ipa"
ENT_IPA_KIT="enterprise"
ENT_IPA_KIT_PATH="$BUILD_BASE/$ENT_IPA_KIT"

STORE_WORKSPACE="$BUILD_BASE/store"
STORE_ARCHIVE_PATH="$STORE_WORKSPACE/store.xcarchive"


echo_in_box 'Determining Build Plan:'
echo "This build intends to produce:"
echo "   - an unsigned Xcode archive"
if [ -n "$ST_DEV_ENTITLEMENTS_PATH" ] && [ -n "$ST_DEV_SIGNING_ID" ] && [ -n "$ST_DEV_IPA_PROFILE_NAME" ]
then
  echo "   - a signed developer ipa"
  MAKING_DEV_IPA=Yes
fi
if [ -n "$ST_ENT_ENTITLEMENTS_PATH" ] && [ -n "$ST_ENT_SIGNING_ID" ] && [ -n "$ST_ENT_IPA_PROFILE_NAME" ]
then
  echo "   - a signed enterprise ipa"
  MAKING_ENT_IPA=Yes
fi
if [ -n "$ST_STORE_ENTITLEMENTS_PATH" ] && [ -n "$ST_STORE_SIGNING_ID" ]
then
  echo "   - a signed Xcode archive"
  MAKING_STORE_ARCHIVE=Yes
fi
echo



# This script assumes that is being run for the top of the tree
# Verify by checking for the .git directory
#
#-# echo "Defining function validate_build_root()"
function validate_build_root()
{
  echo '! Showing BUILD_BASE:'
  echo "$BUILD_BASE"

  if [ ! -e .git ]
  then
    failed "Incorrect default directory - must build from toplevel of the working tree"
  fi
}


#-# echo "Defining function describe_keychain()"
function describe_keychain()
{
  echo '! Listing active keychains:'
  security list-keychains

  echo
  echo '! Listing all CodeSigning identities on keychain:'
  security find-identity -p codesigning -v
}


#-# echo "Defining function describe_environment()"
function describe_environment()
{
  echo '! Showing Who I am:'
  whoami
  echo
  echo "! Showing Operating system:"
  (sw_vers; sysctl -n kern.boottime; date +}%Z) | \
     awk -F '[\t}]' 'NR==3{$0="\tbooted"} {a=a $2 " "} END{print a}'

  echo
  echo "! Showing Available Disk Space:"
  df -m .
  echo
  echo "! Showing Xcode Version:"
  xcodebuild -version
  echo
  # NOTE: the following string is relied upon by iosPublishLogs.sh:
  echo '! Showing Latest Repository Change:'
  git log --format="%h %an %cd %s" -1
}


#-# echo "Defining function describe_project()"
function describe_project()
{
  echo '! Listing Available Schemes:'
  for xcodeproject in `find . -name $BUILD_PROJECT_NAME.xcodeproj` ; do
      xcodebuild -list -project "$xcodeproject"
  done
}


#-# echo "Defining function describe_sdks()"
function describe_sdks()
{
  echo '! Listing Available SDKs:'
  xcodebuild -showsdks
}


#-# echo "Defining function describe_workspace()"
function describe_workspace()
{
  xcodebuild -list -workspace "$BUILD_WORKSPACE_NAME"".xcworkspace"
}


#-# echo "Defining function set_build_version()"
function set_build_version()
{
  local project_plist="$BUILD_PROJECT_NAME/$BUILD_PROJECT_NAME-Info.plist"
  # BUILD_VERSION_PREFIX - defined by the release engineer in Jenkins build exec shell
  # BUILD_NUMBER from Jenkins
  BUILD_VERSION_ID="$BUILD_VERSION_PREFIX$BUILD_NUMBER"

  echo '! Showing BUILD_VERSION_ID:'
  echo "$BUILD_VERSION_ID"

  /usr/libexec/PlistBuddy -c "Set :CFBundleVersion $BUILD_VERSION_ID" $project_plist
}


# This builds an archive that has what we'll eventually want in our enterprise IPA.
# This archive would not be accepted by the Apple Store. This is a Safety Feature.
#-# echo "Defining function build_archive()"
function build_archive()
{
  local project="$BUILD_PROJECT_NAME.xcodeproj"
  local logfile="$BUILD_BASE""/xcodebuild_""$BUILD_PROJECT_NAME"".log"

# The flags below force non-codesiging
# if not explicitly forced not to sign, the code is signed automatically by
# Apple looking up and applying previously used credentials
#
#             CODE_SIGN_IDENTITY=""                                    \
#             CODE_SIGNING_REQUIRED=NO                                 \

  set -x
  xcodebuild -verbose                                                 \
             -workspace     $BUILD_PROJECT_NAME.xcworkspace           \
             -scheme        $BUILD_PROJECT_NAME                       \
             -configuration $BUILD_CONFIGURATION clean build archive  \
             -archivePath   $BUILD_ARCHIVE_PATH                       \
             CODE_SIGN_IDENTITY=""                                    \
             CODE_SIGNING_REQUIRED=NO                                 \
             $BUILD_OPTIONS                                           \
  >| $logfile

  local status=$?
  set +x


# Could explicitly allow mystery errors 65 and 126
#  if [ $status -eq 65 -o $status -eq 126 ]
#  then
#     echo "! xcodebuild exited with status $status."
#     echo 'That can be caused by a wide number of non-terminal trivial issues;'
#     echo 'proceeding as if error did not occur.'
#     status=0
#  fi
  if [ $status -ne 0 ]
  then
    ((errorCount++))
    echo "? xcodebuild $BUILD_PROJECT_NAME failed, code $status" >&2
    echo "! Last 20 lines of ${logfile}:"
    tail -n20 $logfile
  else
    echo "! xcodebuild $BUILD_PROJECT_NAME succeeded; last 3 lines of ${logfile}:"
    tail -n3 $logfile
  fi
}


# This is parameterized, and the workspace contents carefully structured, to
# support building multiple xcarchives.
# Arg1 is the .xcarchive to be verified.
# Arg2 is "signed" if archive signature validity should be verified.
#-# echo "Defining function verify_archive()"
function verify_archive()
{
  set +x
  local xcarchive="$1"

  # verify the archive has the BUILD_VERSION_ID of the app just built

  local archivePlist="$xcarchive/Info.plist"

  local bundleVersion=`/usr/libexec/PlistBuddy -c "Print :ApplicationProperties:CFBundleVersion" $archivePlist`

  if [ "$BUILD_VERSION_ID" != "$bundleVersion" ];
  then
     failed "verify_archive wanted $BUILD_VERSION_ID found $bundleVersion"
  fi
  echo "Archive bundle version: $bundleVersion"

  # list the hardware architectures supported by the xcarchive and verify
  # it matches what was expected
  #
  local archive_app="$xcarchive/Products/Applications/$BUILD_APP_NAME.app"
  local archive_archs=`xcrun -sdk iphoneos lipo -info "$archive_app/$BUILD_APP_NAME"`

  echo '! Displaying Architectures Supported By Archive:'
  echo "$archive_archs"

  local archs_only=`expr "$archive_archs" : '.*:\(.*\)'`
        archs_only="${archs_only%"${archs_only##*[![:space:]]}"}"
        archs_only="${archs_only#"${archs_only%%[![:space:]]*}"}"
  if [ "$archs_only" != "$BUILD_APP_ARCHS" ];
  then
     failed "Archive wrong architectures, expected: $BUILD_APP_ARCHS, found: $archs_only"
  fi

  if [ "$2" == 'signed' ];
  then
     echo
     echo '! Displaying Entitlements In Archive:'
     codesign -d --entitlements :- "$archive_app"

     echo
     echo '! Displaying Signature, etc. In Archive:'
     codesign -d --verbose=4 --file-list - "$archive_app"

     echo
     echo '! Verifying App in Archive:'
     echo "(Verification options: '$VERIFY_OPTIONS')"
     codesign --verify --verbose=4   $VERIFY_OPTIONS  "$archive_app"  || failed verification
  else
     echo
     echo '! Confirming This Archive Is Unsigned:'
     codesign --verify --verbose=4 "$archive_app"
  fi
}


# This is parameterized, and the workspace contents carefully structured, to
# support building multiple IPAs using the same common technique. It works by
# exporting an IPA, then modifying it to be an enterprise or developer IPA with
# the appropriate entitlements and signature. The exported IPA will be nearly
# correct, but we might have to change the bundle ID and bundle display name.
# IPA construction could be done "in place", sort of, but to support
# forensics if it fails, instead the export is to an intermediate IPA. The
# intermediate is unzipped into a copy which is modified and then re-zipped
# to make the final IPA.
#
# Arg1:    IPA path
# Arg2:    IPA kit path
# Arg3:    IPA profile name
# Arg4:    signing ID
# Arg5:    bundle ID to set, if any, else ''
# Arg6:    bundle Display Name to set, if any, else ''
#
#-# echo "Defining function make_ipa_from_archive()"
function make_ipa_from_archive()
{
  local ipa=$1
  local kit=`echo $2|awk -F/ '{print $NF}'`

  mkdir -p -v $2
  pushd       $2 > /dev/null
  touch $kit-make_ipa_from_archive.began

  # make a local copy of the archive
  local ipa_archive_path="$(pwd)/$kit.xcarchive"
  cp -r "$BUILD_ARCHIVE_PATH" "$ipa_archive_path"

  local logfile="$kit-make_ipa_from_archive.log"
  local arc_app="$ipa_archive_path/Products/Applications/$BUILD_APP_NAME.app"
  local app_relpath="Payload/$BUILD_APP_NAME.app"
  local profile_name="$3"
  local signing_id="$4"
  local entitlements_path="$7"

  # If requested, replace the bundle identifier and display name
  if [ -n "$5" ] && [ -n "$6" ]; then
    echo "! Replacing $kit IPA's bundle ID and Display Name:"
    $PlistBuddy -c "Set :CFBundleIdentifier  $5" "$arc_app/Info.plist"
    $PlistBuddy -c "Set :CFBundleDisplayName $6" "$arc_app/Info.plist"
  fi

  cat <<-EOF
	! Initially Copying From:
	    $BUILD_ARCHIVE_PATH
	! Mutating Then Exporting From:
	    $ipa_archive_path
	! Profile File:
	    selected by xcodebuild based on name:
	! Profile Name:
	    $profile_name
	! Finally Producing:
	    $ipa

EOF

  # Sign the archive which appends the entitlements to the program binary
  echo "! Forcibly Signing The Archive:"
  codesign -f --verbose=4 --sign "$signing_id"  \
           --entitlements "$entitlements_path"  \
           "$arc_app"


  # Now export the ipa from the archive for real
  echo '! Re-exporting To Final IPA:'
  set -x
  xcodebuild -verbose                                   \
             -exportArchive                             \
             -exportFormat ipa                          \
             -archivePath "$ipa_archive_path"           \
             -exportPath "$ipa"                         \
             -exportProvisioningProfile "$profile_name" \
  >| $logfile

  local status=$?
  set +x
  if [ $status -ne 0 ]
  then
    ((errorCount++))
    echo "? xcodebuild archive export failed, code $status" >&2
    echo "! Showing Last 20 Lines Of ${logfile}:"
    tail -n20 $logfile
  else
    echo "! Showing Last 3 Lines Of ${logfile}:"
    tail -n3 $logfile
  fi

  touch $kit-make_ipa_from_archive.ended
  popd > /dev/null
}

# This is parameterized, and the workspace contents carefully structured, to
# support building multiple IPAs.
# $1 - path to IPA file
# $2 - path to kit subdirectory
# $3 - empty string or options to add to codesign --verify command
#-# echo "Defining function verify_ipa()"
function verify_ipa()
{
  local ipa=$1
  local kit=`echo $2|awk -F/ '{print $NF}'`
  local ipa_verify_options="$3"
  local app_relpath="Payload/$BUILD_APP_NAME.app"

  mkdir -p -v "$2/vfy"
  pushd "$2/vfy" > /dev/null
  touch $kit-verify_ipa.began

  unzip -q "$ipa"

  echo "! Displaying Entitlements In Binary '$kit' IPA:"
  codesign -d --entitlements :- "$app_relpath"

  echo
  echo "! Displaying Entitlements In embedded.mobileprovision '$kit' IPA:"
  plutil -extract Entitlements xml1 -o - - <<< $(security cms -D  -i "$app_relpath/embedded.mobileprovision")

  echo
  echo "! Displaying App Signature, etc. In '$kit' IPA:"
  codesign -d --verbose=4 --file-list - "$app_relpath"

  echo
  echo "! Verifying App In '$kit' IPA:"
  echo "(Verification options: '$VERIFY_OPTIONS')"
  codesign --verify --verbose=4 $VERIFY_OPTIONS $ipa_verify_options \
           --file-list - "$app_relpath"
  if [ $? -ne 0 ]
  then
    ((errorCount++))
    echo "? '$kit' IPA failed codesign verification" >&2
    touch $kit-verify_ipa.kaput
  else
    touch $kit-verify_ipa.ended
  fi
  popd > /dev/null
}


#-# echo "Defining function make_store_archive_from_archive()"
function make_store_archive_from_archive()
{
  mkdir -p -v $STORE_WORKSPACE
  pushd       $STORE_WORKSPACE > /dev/null
  touch make_store_archive_from_archive.began

  # make a local copy of the archive
  echo "! Copying The Archive:"
  cp -R "$BUILD_ARCHIVE_PATH" "$STORE_ARCHIVE_PATH"

  local arc_app="$STORE_ARCHIVE_PATH/Products/Applications/$BUILD_APP_NAME.app"

  # Sign the archive which appends the entitlements to the program binary
  echo "! Forcibly Signing The Archive:"
  codesign -f --verbose=4 --sign "$ST_STORE_SIGNING_ID" \
           --entitlements "$ST_STORE_ENTITLEMENTS_PATH" \
           "$arc_app"

  touch make_store_archive_from_archive.ended
  popd > /dev/null
}


### FOR POSSIBLE FUTURE USE ###
# $1 - compare base's name
# $2 - compare target's name
#-# echo "Defining function compare_payloads()"
function compare_payloads()
{
  local bKit="$1"
  local dKit="$2"
  local bPath="$1"
  local dPath="$2/vfy"
  local diffOut="$dPath/${bKit}_differences.txt"
  pushd "$BUILD_KITS" > /dev/null

  local appFile=$BUILD_PROJECT_NAME.app

  echo
  echo "! Comparing verified $dKit to $bKit, i.e. these two directories:"
  # ls "rt" options below sort by increasing modification date, so older first
  ls -FLTldrt \
      "$bPath/Payload/$appFile" \
      "$dPath/Payload/$appFile" \
    | sed 's/^/    /'

  diff -qr \
      "$bPath/Payload/$appFile" \
      "$dPath/Payload/$appFile" \
    > $diffOut
  if [ $? -lt 2 ]
  then
    diffCount=`grep -c . $diffOut`
    case $diffCount in
    (0)
      echo "  All $dKit kit $appFile files are identical to the $bKit kit's."
      ;;
    (1)
      echo "  1 $dKit kit $appFile file differs from the $bKit kit's:"
      ;;
    ([2-5])
      echo "  $diffCount $dKit kit $appFile files differ from the $bKit kit's:"
      ;;
    (*)
      echo "  WARNING: $diffCount $dKit kit $appFile files differ from the $bKit kit's."
      echo "  The full list is in $diffOut. The first 5 are:"
      ;;
    esac
    head -5 $diffOut | sed 's/^/  /'
  else
    echo '? Could not compare kits.'
  fi

  popd > /dev/null
}


echo_in_box 'Validating Build Root:'
validate_build_root
echo
if [ -n "$MAKING_DEV_IPA" ] || [ -n "$MAKING_ENT_IPA" ] || [ -n "$MAKING_STORE_ARCHIVE" ]
then
  echo_in_box 'Describing Keychain:'
  describe_keychain
  echo
fi
echo_in_box 'Describing Environment:'
describe_environment
echo
echo_in_box 'Describing SDKs:'
describe_sdks
echo
echo_in_box 'Describing Workspace:'
echo
describe_workspace
echo
echo_in_box 'Setting Build Version:'
echo
set_build_version
echo
echo_in_box 'Building Archive:'
echo
build_archive
echo
echo_in_box 'Verifying Archive:'
echo
verify_archive "$BUILD_ARCHIVE_PATH" 'unsigned'
echo

if [ $MAKING_DEV_IPA ]
then
  echo_in_box 'Making Develop IPA from Archive:'
  echo
  make_ipa_from_archive                 \
    "$DEV_IPA_PATH"                     \
    "$DEV_IPA_KIT_PATH"                 \
    "$ST_DEV_IPA_PROFILE_NAME"          \
    "$ST_DEV_SIGNING_ID"                \
    ''                                  \
    ''                                  \
    "$ST_DEV_ENTITLEMENTS_PATH"
  echo
  echo_in_box 'Verifying Develop IPA:'
  echo
  verify_ipa "$DEV_IPA_PATH" "$DEV_IPA_KIT_PATH" ""
  echo
fi

if [ $MAKING_ENT_IPA ]
then
  echo_in_box 'Making Enterprise IPA from Archive:'
  echo
  make_ipa_from_archive                 \
    "$ENT_IPA_PATH"                     \
    "$ENT_IPA_KIT_PATH"                 \
    "$ST_ENT_IPA_PROFILE_NAME"          \
    "$ST_ENT_SIGNING_ID"                \
    "$ENT_IPA_BUNDLE_ID"                \
    "$ENT_IPA_BUNDLE_DISPLAY_NAME"      \
    "$ST_ENT_ENTITLEMENTS_PATH"
  echo
  echo_in_box 'Verifying Enterprise IPA:'
  echo
  verify_ipa "$ENT_IPA_PATH" "$ENT_IPA_KIT_PATH" ""
  echo
fi

if [ $MAKING_STORE_ARCHIVE ]
then
  echo_in_box 'Making Store Archive from Archive:'
  echo
  make_store_archive_from_archive
  echo
  echo_in_box 'Verifying Store Archive:'
  echo
  verify_archive "$STORE_ARCHIVE_PATH" 'signed'
  echo
fi

#echo_in_box 'Comparing Verified IPA To Archive:'
#echo
#compare_payloads base ent
#echo

echo_in_box "Build Phase Completed! Errors:$errorCount."

echo "Errors:$errorCount" >| errorCount.txt

exit $[ errorCount > 0 ]
